{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 快速开始创建一篇新博客1$ hexo new \"My New Post\" More info: Writing 启动本地服务器1$ hexo server More info: Server 生成静态文件1$ hexo generate More info: Generating 部署到远端1$ hexo deploy More info: Deployment","link":"/2019/08/14/hello-world/"},{"title":"vue-01-vue介绍","text":"Vue介绍 vue作者：尤雨溪 09年 angular 13年 reactjs 14年 vue.js诞生 核心概念： angular 模块化 （用来细分代码） 双向数据绑定 （脏检测：一个数组（$watch）） vue 组件化 （更细分） 双向数据流 (是基于ES5中的 defineProperty 来实现) 双向数据流 1向：JS内存属性发生改变，影响页面的变化 2向：页面的变化影响JS内存属性的变化 框架和库的区别 框架 ：是一套完整的解决方案，对项目侵入比较大，如果需要换框架则需要重新架构 库：就是个插件","link":"/2019/08/15/vue-01-vue介绍/"},{"title":"vue-02-指令和属性","text":"v-cloak 属性 解决插值表达式闪烁问题 在标签中加入v-cloak属性 设置v-cloak的样式 123[v-cloak] { display: none} 1&lt;p v-cloak&gt;{{ msg }}&lt;/p&gt; v-text 属性 默认没有闪烁问题 会覆盖标签中所有内容 123&lt;h4 v-text=\"msg\"&gt;!@#$%^*&lt;/h4&gt;&lt;!-- msg得在data中定义 --&gt;&lt;!-- 里面写再多东西也没用，!@#$%^*会被覆盖 --&gt; v-html 属性 以HTML格式解析字符串 1234567891011&lt;h1 v-html=\"msg\"&gt;&lt;/h1&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { msg: 'hello world', msg1: 'hello 世界', msg2: '&lt;i&gt;我是斜体&lt;/i&gt;' } })&lt;/script&gt; v-bind 指令 给属性绑定值 简写（冒号）： :title=”msg3” 123456789101112&lt;input type=\"button\" value=\"按钮\" v-bind:title=\"msg3 + '123'\" /&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { msg: 'hello world', msg1: 'hello 世界', msg2: '&lt;i&gt;我是斜体&lt;/i&gt;', msg3: 'v-bind用于给属性绑定值' } })&lt;/script&gt; v-on 指令 用于绑定事件 简写： @click=”show()” 123456789101112&lt;input type=\"button\" value=\"按钮\" v-bind:title=\"msg3\" v-on:click=\"show()\" /&gt;&lt;input type=\"button\" value=\"yuanshengshow\" @click=\"yuanshengshow\"&gt; &lt;script&gt; methods: { yuanshengshow: function () { alert('方法的原生写法') }, show() { alert('v-on用于绑定事件') } }&lt;/script&gt; 事件修饰符 .stop 阻止默认的冒泡行为 .prevent 阻止默认行为 .capture 使用捕获触发事件 .self 只点击自己一个人（不冒泡、不捕获）才会触发事件 .once 只触发一次事件处理函数 v-model 双向数据绑定 实现表单元素和model中数据的双向数据绑定 v-model只能用于表单元素中（input、select、checkbox、textarea） 1&lt;input type=\"text\" v-model=\"msg\" /&gt; v-for 指令123456&lt;p v-for=\"(item, i) in list\"&gt;{{ i }}号 -- {{ item.name }} {{ item.sex }} {{ item.age }}&lt;/p&gt;&lt;ul&gt; &lt;li v-for=\"(value, key, index) in obj\"&gt;{{ index }} -- {{ key }} -- {{ value }&lt;/li&gt;&lt;/ul&gt;&lt;li v-for=\"count in 10\"&gt;{{ count }}&lt;/li&gt;&lt;!-- 直接循环数字 --&gt; 特殊的key属性 这个key不是对象中的键，而是每次循环的唯一标识 123&lt;p v-for=\"(item, i) in list\" :key=\"item.age\"&gt; &lt;input type=\"checkbox\"&gt;{{item.name}}--{{item.sex}}--{{i}}&lt;/p&gt; v-if 和 v-show 指令 v-if 会重新删除或创建元素，切换时性能消耗大，适用于显示一遍就不显示了 v-show 只是控制元素的display：none，初始渲染时性能消耗大，适用于频繁切换 123&lt;input type=\"button\" value=\"change\" @click=\"flag=!flag\"&gt;&lt;p v-if=\"flag\"&gt;v-if&lt;/p&gt;&lt;p v-show=\"flag\"&gt;v-show&lt;/p&gt;","link":"/2019/08/15/vue-02-指令和属性/"},{"title":"vue-03-品牌案例及其延伸","text":"品牌案例 详见 code 文件夹 vue 调试工具vue-devtools插件的安装和使用过滤器 Vue.js允许自定义过滤器，可被用作常见的文本格式化。过滤器用在两个地方： mustache插值 v-bind表达式 过滤器被添加在JavaScript表达式尾部，由“管道”符指示 定义语法： 1234&lt;p&gt;{{ msg | msgFormat(a, b, c) }}&lt;/p&gt;定义过滤器Vue.filter(&apos;过滤器名&apos;, function (第一个参数必须是msg, a, b, c) {}) 全局过滤器：所有vue实例都能用 局部（私有）过滤器： 123456789var vm = new Vue({ el: '#app', data: {} methods: {} filters: { dataFormat: function () {} }})//过滤器优先调用私有过滤器 处理字符串新方法（补全字符串）： padStart(补到多长, ‘用什么来补’) //向前补 padEnd(补到多长, ‘用什么来补’) //向后补 自定义键盘修饰符 Vue中给的 @keyup.enter .enter .tab .delete .esc .space .up .down .left .right 可以通过全局 config.keyCodes 对象自定义来使用 1Vue.config.keyCodes.f1 = 112 1&lt;input @keyup.f1=\"add()\"&gt; 自定义全局指令12&lt;input type=\"text\" v-focus &gt;&lt;!-- 设置指令时得加 v- 定义时不用 --&gt; 123456789101112Vue.directive('focus', { bind: function (el) { //el 就是原生的DOM元素 //bind: 绑定到el上的指令会在el插入到页面之前执行，只执行一次 }, inserted: function (el) { //inserted：el插入到页面中后才执行，只执行一次 }, updated: function (el) { //当VNode更新时会执行，可能执行多次 }}) 第一个参数必须 el 第二个参数 1&lt;th v-color=\"'red'\"&gt;ID&lt;/th&gt; 123456Vue.directive('color', { bind: function (el, binding) { console.log(binding) el.style.color = binding.value } }) 自定义私有指令12345678910111213var vm = new Vue({ el: '#app', data: {}, methods: {}, filters: {}, directives: { 'focus': { bind: function (el) {}, inserted: function (el) {}, updated: function (el) {} } }}) 自定义指令简写123456 Vue.directive('color', function (el, binding) { console.log(binding) el.style.color = binding.value } )//不写成对象形式，会默认写在了bind和updated里面 Vue生命周期 生命周期事件=生命周期函数=生命周期钩子 12345678beforeCreate //初始化生命周期created // 可以获得data中的数据和methods中的方法beforeMount //挂起之前渲染模板mounted //模板挂起完毕beforeUpdate //数据改变触发才会beforeUpdate，然后创建虚拟Dom重新渲染updated //重新渲染完毕beforeDestorydestoryed vue-resource(axios)实现get,post,jsonp请求 vue-resource依赖vue vue.js是定义了Vue构造函数，vue-resource是在vm实例上挂载了$http属性 get请求： 12345678910methods:{ get:function(){ //发送get请求 this.$http.get('/try/ajax/ajax_info.txt').then(function(res){ document.write(res.body); },function(){ console.log('请求失败处理'); }); } } post请求 post发送数据到后端，需要第三个参数{emulateJSON:true} emulateJSON 的作用： 如果Web服务器无法处理编码为 application/json 的请求，你可以启用 emulateJSON 选项。 12345678910methods: { post: function () { this.$http.post('/demo.php', {name: 'jack'}, {emulateJSON: true}) .then(function (res) { }, function (err) { }) }} jsonp请求 12345678910methods:{ get:function(){ //发送jsonp请求 this.$http.jsonp('/try/ajax/ajax_info.txt').then(function(res){ document.write(res.body); },function(){ console.log('请求失败处理'); }); } } 设置根地址： 1Vue.http.options.root = 'http://vue.studyit.io/' 发请求是使用相对路径且不要带斜线 1this.$http.get('try/ajax/ajax_info.txt').then() 全局配置{emulateJSON: true} Vue.http.options.emulateJSON = true","link":"/2019/08/15/vue-03-品牌案例及其延伸/"},{"title":"vue-04-vue动画","text":"vue动画使用过渡类名实现动画 v-enter v-enter-active v-enter-to v-leave v-leave-active v-leave-to 设置动画 12345678910111213141516171819202122&lt;style&gt; .v-enter, .v-leave-to { opacity: 0; transform: translateX(150px) } .v-enter-active, .v-leave-active { transition: all 0.8s ease } //自定义v-前缀 .my-enter, .my-leave-to { opacity: 0; transform: translateX(500px) } .my-enter-active, .my-leave-active { transition: all 1s ease } &lt;/style&gt; 使用官方提供的标签transition把需要被动画控制的元素包裹起来 12345678910&lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"change\" @click=\"flag=!flag\"&gt; &lt;transition&gt; &lt;h3 v-if=\"flag\"&gt;helloworld&lt;/h3&gt; &lt;/transition&gt; &lt;transition name=\"my\"&gt; &lt;!-- 加个name来定义自己的动画 --&gt; &lt;h3 v-if=\"flag\"&gt;helloworld&lt;/h3&gt; &lt;/transition&gt; &lt;/div&gt; 使用钩子函数实现动画 v-on:before-enter=”beforeEnter” v-on:enter=”enter” v-on:after-enter=”afterEnter” 123456789101112beforeEnter(el) { el.style.transform = \"translate(0, 0)\" }, enter(el, done) { el.offsetWidth //这句话没实际作用，可以认为强制动画刷新 el.style.transform = \"translate(150px, 450px)\" el.style.transition = 'all 1s ease' done() //done其实是afterEnter的引用，动画完成后立即执行afterEnter }, afterEnter(el) { this.flag = !this.flag } 列表的排列过渡用 给transition-group添加appear属性，实现一个入场效果 设置tag=”ul”指定transition-group渲染成ul，否则默认渲染成span","link":"/2019/08/15/vue-04-vue动画/"},{"title":"Vue全家桶之Vuex","text":"Vuex是什么？Vuex 我姑且称之为vue老爷的管家 刚开始学vuex的时候，它给我的感觉类似于cookie、local Storage这种东西。使用时给我带来最方便的就是让组件传值变得更加方便了。 官方把vuex称为状态管理模式（State Management Pattern）。 vuex分为3个part： View 视图 Action 行为 State 状态数据 怎么运作的： 页面上的一些操作会触发Actions中的一些方法 Actions改变State中的数据 State中数据有反馈给页面呈现 Vuex好在哪儿？传统组件传值弊端： 组件层层嵌套多了会导致传值非常麻烦，尤其是兄弟组件传值 代码不易维护 解决办法： 把共享的数据抽离出来单独存放 写一些api去操作数据 这样不管哪个组件要用，直接调用api即可 好处： 代码清晰，维护简单 什么时候应该用vuex？ 这个问题参考了vuex官方的解释才明白 简单来说： 中大型单页应用：vuex 小型应用：store模式足矣 注意事项：1、Vuex和全局对象的区别 vuex中的状态是响应式的 改变状态不能直接操作，而是显式地提交mutation。目的是为了把状态的变更记录更好的了解我们的应用 Vuex的核心概念 State 定义数据 Getters 定义一些方法直接获取State中的数据（或者处理后的数据），跟computed一样 Mutations 定义唯一改变State中数据的方法，第一个参数必须是state，剩下的随便 Actions 提交执行Mutations的地方 Module 用来分隔store成一个个模块，以免变得太大太臃肿 State 首先在一个js文件中声明一个store 123456789101112131415161718import Vue from 'vue'import Vuex from 'vuex'import todo1 from './modules/todo1.js'import todo2 from './modules/todo2.js'import todo3 from './modules/todo3.js'Vue.use(Vuex)const store = new Vuex.Store({ modules: { todo1, todo2, todo3 }})//把这个小仓库暴露出去export default store 然后编写一个个模块，这些模块组成一整个store 在modules目录下建立todo1.js 123456789101112131415161718192021222324 const state = { todos: [] //这是我们的数据或状态 } const getters = { //可以认为是计算属性，返回值会被缓存 getAllTodos (state, num) { //第一个参数必须是state，其他的可以自己加 return state.todos[0] + num //这种情况直接返回了一个值，所以结果会被缓存 }, getTodoById (state) { return (id) =&gt; state.todos.find(todo =&gt; todo.id === id) } //这种情况返回的是一个函数，每次都会被调用所以不会缓存结果，要注意 } const mutations = { //更改state的唯一方法 todosPush (state, num) { //调用时得用store.commit('todosPush', 123) state.todos.push(num) } } const actions = { todosPush ({ commit }) { //注意：1、actions里的方法第一个参数是跟store具有相同属性和方法的context对象。2、actions里的方法都通过store.dispatch('todospuah')触发 commit('todospush', 123) } } 未完待续。。。","link":"/2019/08/15/vue-07-vuex/"},{"title":"webpack-01-基本配置","text":"nrm ls1234567 npm -------- https://registry.npmjs.org/ yarn ------- https://registry.yarnpkg.com/ cnpm ------- http://r.cnpmjs.org/* taobao ----- https://registry.npm.taobao.org/ nj --------- https://registry.nodejitsu.com/ npmMirror -- https://skimdb.npmjs.com/registry/ edunpm ----- http://registry.enpmjs.org/ nrm use npm 更改下载的镜像 1234567* npm -------- https://registry.npmjs.org/ yarn ------- https://registry.yarnpkg.com/ cnpm ------- http://r.cnpmjs.org/ taobao ----- https://registry.npm.taobao.org/ nj --------- https://registry.nodejitsu.com/ npmMirror -- https://skimdb.npmjs.com/registry/ edunpm ----- http://registry.enpmjs.org/ webpack可以做什么 处理js文件的相互依赖关系 处理浏览器的兼容问题，把高级的、浏览器不兼容的转为低级的 webpack基本使用 安装webpack在全局，就可以在全局使用webpack命令。注意版本别太高 1npm i webpack@3 -g 在项目根目录中运行 1npm i webpack --save-dev 安装到项目依赖中 使用webpack打包构建列表隔行变色案例 运行npm init -y初始化项目 创建项目基本结构目录 安装jQuery库 npm i jquery@1 -S 创建mian.js写代码逻辑 1234567//导入jQueryimport $ from 'jquery'//注意千万别像我似的把属性名写错了找半天找不出来$(function () { $('li:even').css('background-color', 'red') $('li:odd').css('background-color', 'green')}) 在页面中直接引入main.js会报错，因为浏览器不认识import这种高级语法 用webpack对main.js进行打包 1webpack ./src/js/main.js ./dist/bundle.js 然后把页面中引入mian.js变成引入bundle.js 使用webpack的配置文件简化打包时候的操作 在项目根目录中创建webpack.config.js 由于运行webpack时需要入口和出口两个文件，所以需要配置 12345678910//引入路径模块const path = require('path')//导出配置对象module.exports = { entry: path.join(__dirname, './src/js/main.js'), output: { path: path.join(__dirname, './dist'),//输出的文件目录 filename: 'bundle.js' //输出的文件名 }} 这样就可以直接使用webpack（不用加参数）命令进行打包了","link":"/2019/08/15/webpack-01-webpack基本配置/"},{"title":"webpack-02-自动打包、插件、Babel等怎么搞","text":"使用webpack-dev-server工具实现自动打包编译 安装webpack-dev-server到本地依赖 1npm i webpack-dev-server@2 -D 一定要注意版本问题，我亲测 webpack版本别太高，webpack-dev-server别比webpack还高 webpack-dev-server帮我们打包生成的bundle.js文件，没有存放在物理磁盘中 而是在内存中放在了项目根目录，所以在实际磁盘中查不到。 这样每次编译时速度快，减少磁盘消耗 webpack-dev-server的常用命令 想打包完成后 自动打开浏览器 –open 自定义端口 –port 3000 自定义展示目录 –contentBase src 不重新编译，而是给bundle.js打补丁 –hot 第一种方法： 1webpack-dev-server --open --port 3000 --contentBase src --hot 第二种方法： 在webpack.config.js中 12345678910111213141516171819const path = require('path')const webpack = require('webpack')module.exports = { entry: path.join(__dirname, './src/main.js'), output: { path: path.join(__dirname, './dist'), filename: 'bundle.js' }, devServer: { open: true, port: 3000, contentBase: 'src', hot: true //想要hot生效，必须先配置下面的plugins }, plugins: [ new webpack.HotModuleReplacementPlugin() ]} html-webpack-plugin插件作用： 自动在内存中根据指定页面生成内存的页面 把打包好的bundle.js追加到页面中去 12345678910111213141516171819202122const htmlWebpackPlugin = require('html-webpack-plugin')module.exports = { entry: path.join(__dirname, './src/main.js'), output: { path: path.join(__dirname, './dist'), filename: 'bundle.js' }, devServer: { open: true, port: 3000, contentBase: 'src', hot: true }, plugins: [ new webpack.HotModuleReplacementPlugin(), new htmlWebpackPlugin({ template: path.join(__dirname, './src/index.html'), //模板在哪儿 filename: 'index.html' //在内存中叫啥名 }) ]} webpack默认只能打包js文件，如要处理css或其他类型文件 先在main.js中引入 1import './css/index.css' 安装style-loader css-loader包 在webpack配置中有个module属性 1234567module.exports = { module: { rules: [ {test: /\\.css$/, use: ['style-loader', 'css-loader']} ] }} webpack处理文件的过程 判断是否是js文件？是，直接打包；不是，查找对应的第三方loader（在use里找，从后往前找） 默认webpack无法处理CSS中的url url-loader内部依赖file-loader 1npm i url-loader file-loader -D 1{ test: /\\.(jpg|png|gif|jpeg)$/, use: 'url-loader' } 配置完后webpack对图片的操作是将图片用base64编码，直接跟页面一起请求，避免二次请求 我们要求小图片才这样处理，大图片正常加载 于是乎设置了limit参数 1{ test: /\\.(jpg|png|gif|jpeg)$/, use: 'url-loader?limit=12470' } 我测试的是图片大小等于12470时仍然是base64编码 如果图片大小超出limit，图片名称就会变为 32位哈希值.扩展名 但我们还是可以改成我们原来的名称 1{ test: /\\.(jpg|png|gif|jpeg)$/, use: 'url-loader?limit=12470&amp;name=[name].[ext]' } 但会出现问题：如果两张名称一样的图片在两个文件夹中都被引入，就会出现覆盖。因此， 在前面添加哈希值保证唯一名称 1{ test: /\\.(jpg|png|gif|jpeg)$/, use: 'url-loader?limit=12470&amp;name=[hash:8]-[name].[ext]' } url-loader也可处理字体文件 1{ test: /\\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader' } webpack用babel处理高级语法 加载用于语法转换的插件 1npm i babel-core babel-loader babel-plugin-transform-runtime -D ​ 加载语法转换的规则 1npm i babel-preset-env babel-preset-stage-0 -D 在webpack.config.js中配置 12{ test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/ }//exclude表示用不着转换node_module中的代码 在项目根目录建立.babelrc文件（json格式） 1234{ \"presets\": [\"env\", \"stage-0\"], \"plugins\": [\"transform-runtime\"]}","link":"/2019/08/15/webpack-02-自动打包和插件、Babel/"},{"title":"vue-05-vue组件","text":"vue组件啥是组件？为了拆分vue实例的代码量，能够让我们以不同的组件，来划分不同的功能模块，将来需要什么样的功能，就去调用对应的组件 。 组件化和模块化的不同： 模块化：按照代码逻辑来划分成不同的模块，方便代码分层开发，保证每个模块功能的单一。 组件化：按照UI界面进行划分，方便UI组件的重用。 创建组件的3种方式 123Vue.componemt('mycom1', Vue.extend({ template: '&lt;h3&gt;这是一个组件&lt;/h3&gt;'})) 123Vue.component('mycom2', { template: '&lt;div&gt;&lt;/div&gt;'}) 12345678&lt;template id=\"tmpl\"&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;Vue.component('mycom2', { template: '#tmpl'}&lt;/script&gt; 创建私有组件12345678910111213141516171819202122&lt;template id=\"login\"&gt; &lt;div&gt; 一个私有组件 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: {}, methods: {}, components: { login: { template: '#login' } }, filters: {}, directives: {}, beforeCreate () {}, })&lt;/script&gt; 组件中的data 组件中的data必须写成function形式，并且得返回一个对象 12345678Vue.component('mycom', { template: '&lt;h1&gt;{{ msg }}&lt;/h1&gt;', data: function () { return { msg: 'helloworld' } }}) 组件切换 除了v-if v-else外，用component标签占位可以来实现切换 123456&lt;component :is=\"'login'\"&gt;&lt;/component&gt; //双引号里必须是字符串，要不然会把它看成变量&lt;script&gt; Vue.component('login', { template: '&lt;h3&gt;deng'lu&lt;/h3&gt;' })&lt;/script&gt; 组件切换加动画和mode mode=”out-in”先出后进 in-out 先进后出 123&lt;transition mode=\"out-in\"&gt; &lt;component :is=\"comName\"&gt;&lt;/component&gt;&lt;/transition&gt; 父组件向子组件传值 在子组件上绑定父属性 用props注册传过来的值的名（注意命名） 123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;son :parentmsg=\"msg\" :tip=\"msg2\"&gt;&lt;/son&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: '#app', data: { msg: 'helloworld', msg2: '命名还有讲究' }, methods: { }, components: { son: { template: '&lt;h3&gt;i want to say {{ parentmsg }} {{ tip }}&lt;/h3&gt;', props: ['parentmsg', 'tip'] } } }) &lt;/script&gt; 父组件向子组件传方法 先创建子组件 使用子组件时，给来自父组件的方法起个别名sonfunc 使用this.$emit(‘别名’，第一个形参，第二个形参) 12345678910111213141516171819202122232425262728293031&lt;div id=\"app\"&gt; &lt;son @sonfunc=\"fatherfunc\"&gt;&lt;/son&gt; &lt;/div&gt;&lt;template id=\"son\"&gt; &lt;input type=\"button\" value=\"show\" @click=\"myclick\"&gt;&lt;/template&gt; &lt;script&gt; var vm = new Vue({ el: '#app', data: { msg: 'helloworld', msg2: '命名还有讲究' }, methods: { fatherfunc(a, b) { console.log('fatherfunc 被调用'+' '+a+b) } }, components: { son: { template: '#son', props: ['parentmsg', 'tip'], methods: { myclick() { this.$emit('sonfunc', '第一个参数', '第二个参数') } } } } }) &lt;/script&gt;","link":"/2019/08/15/vue-05-vue组件/"},{"title":"webpack-03-webpack与vue的结合","text":"使用vue实例的render方法渲染组件123456789101112131415var vm = new Vue({ el: '#app', data: { }, methods: { }, components: { }, render: function (createElements) { return createElements(login) } }) 会被login完全覆盖（有点类似于v-text） 区分webpack中导入vue和普通网页中引入vue.js的区别import Vue from ‘vue’ 会带来如下操作： 先去node_modules文件夹中找vue模块 然后去package.json中找vue模块的main属性，但main指向的时vue-runtime-only.js 这样不行，我们要的是vue.js 所以可以这么做： 1、更改main的值为vue.js或vue.min.js 2、import Vue from ‘../node_modules/vue/dist/vue.js’ 3、配置webpack.config.js文件 1234567module.exports = { resolve: { alias: { 'vue$': 'vue/dist/vue.esm.js' } }} 使用export default和export向外暴露成员export default 只能有一个 1234export default { name: 'zhangsan', age: 20} 可以自定义变量名称接收接收 1import person from './person.js' export 可以写多个 12export var name = 'lisi'export var age = 21 必须使用{原名, 原名}接收但也可以用as改名 1import { name, age as myCallAge } from './person.js' webpack使用vue-router123import VueRouter from 'vue-router'Vue.use(VueRouter) 组件中style标签的lang属性和scoped属性123456789&lt;style lang=&quot;scss&quot; scoped&gt; body { div { font-size: italic; } }&lt;/style&gt;//lang设置用css、scss、less等哪种语言写//scoped设置样式是组件的，如果不设置就会变成全局的","link":"/2019/08/15/webpack-03-与vue的结合/"},{"title":"nodejs-核心模块之文件模块的初探","text":"node为JS提供了很多服务器级别的API，这些API绝大部分在核心模块里。需要用require加载 我认为这是node.js与浏览器中的JS的很重要的不同正是这些模块让JS具备了服务端开发的能力 读文件1、用require方法加载fs核心模块1var fs = require('fs') 2、读取文件123456fs.readFile('./hello.txt',function(error,data){ if(error) return \"读取文件失败\" console.log(data.toString()) //注意此处如果直接打印data，会输出十六进制的数据 //必须用toString()转换成人类能看懂的}) 第一个参数传文件路径 第二个参数传回调函数 如果读取成功 error : null data : 数据 如果读取失败 error : 错误对象 data : undefined写文件1、加载文件模块1var fs =require('fs') 2、写入文件123fs.writeFile('./hello.txt','hello nodejs',function(error){ console.log(error)}) 参数分别为文件路径、想要写入的内容、回调函数（写入成功error：null;写入失败error: 错误对象）","link":"/2019/08/15/我第一天学nodejs的笔记01/"},{"title":"vue-06-vue路由","text":"vue-router 引包vue-router.js 12&lt;script src=\"./lib/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"&gt;&lt;/script&gt; 声明一个路由实例 12345678&lt;script&gt; var router = new VueRouter({ routes: [ {path: '/', redirect: '/login'}, {path: 'url', component: 注意这里是组件的原型而不是组件的引用标签} ] })&lt;/script&gt; 在vm中注册 12345678910&lt;script&gt; var vm = new Vue({ el: data: methods: filters: direvtives: router: router // })&lt;/script&gt; 在页面中使用 123456&lt;div id=\"app\"&gt; &lt;router-link to=\"/login\" tag=\"span\"&gt;登录&lt;/router-link&gt; &lt;!-- 发送路由的标签 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- 承载组件的容器router-view --&gt;&lt;/div&gt; 给linkActiveClass自定义样式实现高亮显示1234567891011121314&lt;style&gt; .myStyle { }&lt;/style&gt;&lt;script&gt; var router = new VueRouter({ routes: [ {path: '/', redirect: '/login'}, {path: 'url', component: 注意这里是组件的原型而不是组件的引用标签} ], linkActiveClass: 'myStyle' })&lt;/script&gt; query查询的方式传值，在对应的组件中就可以拿到值this.$route.query.id123456&lt;div id=\"app\"&gt; &lt;router-link to=\"/login?id=123\" tag=\"span\"&gt;登录&lt;/router-link&gt; &lt;!-- 发送路由的标签 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- 承载组件的容器router-view --&gt;&lt;/div&gt; params方式传值12345678910&lt;script&gt; var router = new VueRouter({ routes: [ {path: '/', redirect: '/login'}, {path: 'url', component: 注意这里是组件的原型而不是组件的引用标签}, {path: '/login/:id/:name', component: login} // : 是占位符的意思，传值的时候表示 id：'123', name: 'zhangsan' ], linkActiveClass: 'myStyle' })&lt;/script&gt; 传值：(通过this.$route.params.id this.$route.params.name拿到) 123456&lt;div id=\"app\"&gt; &lt;router-link to=\"/login/123/zhangsan\" tag=\"span\"&gt;登录&lt;/router-link&gt; &lt;!-- 发送路由的标签 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- 承载组件的容器router-view --&gt;&lt;/div&gt; 路由的嵌套（children）使用命名视图实现经典布局1234567891011121314151617181920212223&lt;router-view&gt;&lt;/router-view&gt;&lt;router-view name=\"left\"&gt;&lt;/router-view&gt;&lt;router-view name=\"main\"&gt;&lt;/router-view&gt;&lt;script&gt; var header = { template: '&lt;h3&gt;header&lt;/h3&gt;' } var left = { template: '&lt;h3&gt;left&lt;/h3&gt;' } var main = { template: '&lt;h3&gt;main&lt;/h3&gt;' } var router = new VueRouter({ routes: [ {path: '/', components: { 'default': header, 'left': left, 'main': main }}, })&lt;/script&gt; watch 用来监听data中值的改变（优势在于可以监听非DOM元素的改变）1234567891011121314151617&lt;script&gt; var vm = new Vue({ el: data: { msg: 123 } methods: filters: direvtives: router: watch: { msg: function (newVal, oldVal) { //一旦msg变化就会触发这个方法，两个形参（改变后的值， 改变之前的值） } } })&lt;/script&gt; 比如: 监听路由改变 12345678910111213141516171819&lt;script&gt; var vm = new Vue({ el: data: { msg: 123 } methods: filters: direvtives: router: watch: { '$route.path': function (newVal, oldVal) { if (newVal === '/login') { console.log('欢迎进入登录页面') } } } })&lt;/script&gt; computed计算属性 computed里声明的是函数，但我们把它当作属性来用（v-model=””） 声明的函数所用到的值一旦变化就会重新计算 求值的结果会被缓存起来，方便下次使用，声明的函数所用到的值不变就不会重新计算 12345678910111213141516171819&lt;script&gt; var vm = new Vue({ el: data: { msg1: 123, msg2: 456 } methods: filters: direvtives: router: watch: {}, computed: { 'result': function () { return this.msg1 + this.msg2 } } })&lt;/script&gt; computed、methods、watch对比 computed 虽然是函数但被当作属性来使用，属性的结果会被缓存，主要用于对数据的处理后得到一个结果 methods 表示一个具体的操作，主要用来书写业务逻辑 watch 键是需要观察的东西，值是键改变之后的回调函数，用于监听特定的数据变化，仿佛是computed和methods的结合","link":"/2019/08/15/vue-06-vue路由/"},{"title":"nodejs-笔记（一）","text":"node.js官网链接：http://nodejs.org技术相关的网站大部分都以.org或.io结尾 1、node是什么？ node是基于chrome V8 JS引擎的运行环境 可以解析和执行JS代码 以前只有浏览器可以 现在用node之后可以脱离浏览器来运行JS 2、node.js的特性 使用事件驱动、非阻塞I/O模型（就是异步）、轻量和高效 npm是世界上最大的开源库生态系统3、浏览器中的JS与node.js的区别 浏览器中的JS： 遵循ES语法 BOM操作 DOM操作 node.js: 遵循ES语法 没有DOM和BOM node提供的服务器级别的API 文件读写 网络服务构建 网络通信 HTTP服务器……4、node.js能做什么？ web服务器 命令行工具 npm(node) git(C语言) hexo(node)……","link":"/2019/08/15/我第一天学nodejs的笔记00/"},{"title":"nodejs-模块系统、npm、package.json、Express","text":"模块系统模块分类 核心模块 fs http url path os 等等 第三方模块 art-template npm下载的模块 自己写的模块require加载机制和规则 无论加载什么模块，优先从缓存中加载 第一次我要加载a，a又依赖b，那么我会将a和b都加载过来。 第二次我要加载b,我就不需要重新加载b，因为a依赖b，所以缓存中有b，这样我就直接读缓存 核心模块直接加载 路径形式的文件模块，按路径加载 第三方模块（以art-template为例） 找node_modules/art-template/package.json里的main index.js备选项 如果不行，进入上一级目录找node_modules 如果还找不到，继续往上找，直到磁盘根目录还是找不到就报错循环加载 如果a模块引入b，b模块有引入a的话，就说明本身设计就有问题 npm node package manager npm命令 npm -v 查看版本 npm install –global npm 更新npm npm init 初始化项目要的包，在目录中生成node_modules和package.json npm init -y 跳过向导，快速生成package.json npm install 包名 安装包 npm install –save 包名 下载并保存依赖项到package.json中 npm i -S 包名 （简写） npm uninstall 包名 依赖项会保存，不会被删掉 npm uninstall –save 包名 删依赖项 npm un -S 包名 （简写） npm –help 查看帮助 npm 操作 –help 查看具体操作的帮助 npm config list 查看配置信息 不想安装cnpm又想用淘宝服务器来下载 1npm install jquery --registry=https://registry.npm.taobao.org 但每次这么加参数很麻烦，可以这样 1npm config set registry https://registry.npm.taobao.org package.json 建议每个项目都要有一个package.json文件（对项目的说明） package.json可以通过npm init初始化出来 根据init向导填写项目信息 如果项目中的node_modules没了也不用担心， npm install 会根据package.json把所有的依赖项都下回来 Express初探 原生的http在某些方面表现不足以应对我们的开发需求 123456789101112var express = require('express')var app = express()app.use('/public/', express.static('./public/'))app.get('/about', function (req, res) { res.send('hello express')})app.listen(3000, function () { console.log('running')}) 之后我真正独立地用express重写了留言板demo，见下一篇","link":"/2019/08/15/我第三天学nodejs的笔记00/"},{"title":"nodejs-用express重写留言板","text":"关于留言板的总体介绍在《留言板-demo》里下面直接用express框架开写 在写之前，为减少代码出错或者更改后服务器得重新重启，可以安装nodemon，这样每次文件有变动都会自动重启。设置修改代码自动重启，这样不用每次都重启安装一个第三方命令行工具 1npm install --global nodemon 安装完毕后，使用 1nodemon app.js 即可 1、安装express模块和art-template1npm i -S express art-template express-art-template 2、引入express模块123var express = require('express')var app = express() 3、配置使用模板引擎1234app.engine('html', require('express-art-template'))//评论数据var comments =[] 4、写路由（中间件）12345678910111213141516171819202122232425262728//开放/public/,这样直接就把样式库开放了app.use('/public/', express.static('./public/'))//请求/，返回index.htmlapp.get('/', function (req, res) { res.render('index.html', { comments: comments })})//请求/post,返回post.htmlapp.get('/post', function (req, res) { res.render('post.html')})//写完评论后请求/pinglun,将评论添加到comments里，然后重定向到主页面app.get('/pinglun', function (req, res) { var comment = req.query //添加评论时间 var date = new Date() comment.dateTime = date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate() + ' ' + date.getHours() + ':' + date.getMinutes() + ':' + date.getSeconds() comments.unshift(comment) //设置重定向 // res.statusCode = 302 // res.setHeader('Location', '/') // res.send() res.redirect('/')}) 5、打开监听，启动服务123app.listen(3000, function () { console.log('running...')}) 下篇：结合mongodb的一个多人社区的案例（之前学的时候老师只讲了一部分，我会把案例做完整之后整理下来）","link":"/2019/08/15/我第三天学nodejs的笔记01/"},{"title":"nodejs-在node中使用模板引擎art-template渲染页面","text":"web浏览器里的art-template是这样的 12345678910111213141516171819&lt;body&gt;&lt;!-- 引入模板 --&gt;&lt;script src=\"node_modules/lib/art-template\"&gt;&lt;/script&gt;&lt;script type=\"text/template\" id=\"tpl\"&gt;{{ name }}{{ each hobbies }}{{ $value }}{{ /each }}&lt;/script&gt;&lt;script&gt;var ret = template('tpl', { name : 'zhangsan' hobbies : [ 'football', 'soccer' ]})&lt;/script&gt;&lt;/body&gt; node中的art-template 安装 1npm install art-template 加载模块 1var template = require('art-template') 使用模板引擎 123var ret = template.render(模板字符串, { //替代的内容}) 客户端和服务端渲染的区别 客户端渲染：（异步渲染） 两次请求 页面请求 Ajax数据请求 不利于SEO搜索引擎优化 很难被爬虫抓取到 右键查看网页源代码查不到 比如：商品评论 服务端渲染： 一次请求 有利于SEO搜索引擎优化 很难被爬虫抓取到 右键查看网页源代码可查到 比如：商品信息 所以，真正的网站都是两种渲染结合来做的例如：京东商品列表采用服务端渲染，利于搜索引擎抓取商品评论为了用户体验，而且不需要SEO优化","link":"/2019/08/15/我第二天学nodejs的笔记01/"},{"title":"nodejs-用node轻松构建一个web服务器（http模块）","text":"与fs文件模块一样，http模块也是nodejs核心模块中的一个当学到这儿的时候我突然真正体会到了模块化编程究竟是什么样的过程 http模块之请求1、引入http模块1var http = require('http') 2、实例化一个web服务器1var server = http.createServer() 3、注册request请求事件1234server.on('request',function(){ console.log('服务器收到请求了！') //一旦有请求过来就能触发回调函数}) 4、绑定端口号，启动服务器123server.listen(3000,function(){ console.log(server is running……)}) http模块之响应这部分一气呵成12345678var http =require('http')var server = http.createServer()server.on('request',function(req,res){ console.log('服务器收到请求了！') //res对象有一个方法，用来给客户端发送响应 res.write('hello nodejs') res.end() //这个方法用来结束客户端等待，要不然浏览器会一直转圈}) http模块之Content-Type 学到这的时候我突然回忆起了当时学php的时候也是需要在请求头中设置Content-Type来解决浏览器的识别编码的问题看来无论是什么语言都有这一步的操作 1234567var http = require('http')var server = http.createServer()server.on('request',function(req,res){ res.setHeader('Content-Type','text/plain;charset=utf-8') res.end('hello 世界')})sercer.listen(3000,function(){}) 为什么？ 服务器发送的数据其实是utf-8编码的内容。 但浏览器不知道是什么编码方式，所以它只会按照操作系统默认的方式解码。 因此，服务器得告诉浏览器，我的内容是个文本（text）,你按照plain的格式来解析，字符按照utf-8编码方式解析 Content-Type有哪些？ 不同的资源对应的Content-Type是不一样的。 可以在常用对照表参考 图片不需要指定编码。 一般只为字符数据指定编码（没有字符的话;charset=utf-8可以不写）","link":"/2019/08/15/我第一天学nodejs的笔记02/"},{"title":"nodejs-深入理解nodejs中的模块","text":"引言：node为JS提供了很多服务器级别的API，这些API绝大部分在核心模块里，需要用require加载 1、node模块有三种 具名的核心模块 fs http os …… 用户自己编写的模块 相对路径必须加 ./ ，不能省略，否则就把它当成核心模块了 可以省略后缀名2、node中没有全局作用域 内部访问不到外部 外部访问不到内部 3、如何让模块与模块之间通信呢？ exports module.exports在一个模块中，node会隐式地 12345var module = { exports = {}}var exports = module.exportsreturn module.exports 由此可见，exports和module.exports是用来导出模块中想要对外展示的成员，所以我们可以把要对外展示的成员这么写： 12345678910//导出一个成员module.exports = 成员//这样可以在别的模块require之后就用//或者exports.成员名 = 成员//这样在别的模块require之后，还得.成员名之后再用//导出多个成员module.exports = { //里面写成员}","link":"/2019/08/15/我第二天学nodejs的笔记00/"},{"title":"nodejs-留言板-demo","text":"要点：1、处理路由（对请求的处理）2、对fs、http、art-template模块的运用 步骤1、新建一个目录，用npm对项目进行初始化 在项目目录下 1npm init 按照npm的提示引导填写项目信息 或者直接用这个进行默认初始化 1npm init -y 这时在项目目录下会产生 node_modules 文件夹 所有要用到的模块都放在这 核心模块 自己加载的第三方模块 package.json 文件 存储项目信息和模块依赖 继续在项目目录新建如下文件结构 public 存放公开的静态资源 css img js lib views 存放页面 app.js 服务的启动文件 README.md 项目的说明文件 安装art-template模板引擎模块也是在项目目录 1npm install --save art-template 此时在package.json中可以观察到依赖项”dependencies”多了个art-template 2、打开app.js开始编写服务程序如下是程序代码（第一次学的时候写了很详细的注释） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//引入核心模块var http = require('http')var fs = require('fs')var template = require('art-template')var url = require('url')//暂且用数组来存放留言数据var comments = []//使用http实例创建服务器http .createServer(function (req,res) { //url模块可以用来提取url中的信息 var parseObj = url.parse(req.url, true) var pathName = parseObj.pathname //url请求根目录 / if (pathName === '/') { //fs模块实例读取文件 fs.readFile('./views/index.html', function (err, data) { if (err) { return res.end('404 Not Found1.') } //使用模板引擎的render()将留言数据渲染到index.html页面 var htmlStr = template.render(data.toString(), { comments : comments }) //结束浏览器等待并返回页面 res.end(htmlStr) })//url请求写留言页面，此处判断请求是否是以/post开头 } else if (pathName.indexOf('/post') === 0) { //跟上面一样也是读文件然后返回 fs.readFile('./views/post.html', function (err, data) { if (err) { return res.end('404 Not Found2') } res.end(data) })//页面中有些link请求css样式 } else if (pathName.indexOf('/public/') === 0) { //你请求啥，我就利用你请求的路径去去啥（pathName） fs.readFile('.' + pathName, function (err, data) { if (err) { return res.end('404 Not Found3') } res.end(data) })//url提交评论请求 } else if (pathName === '/pinglun') { //提取url中？后面的信息并返回一个对象 var comment = parseObj.query var dateTime = new Date() comment.dateTime = dateTime.getFullYear()+'-'+(dateTime.getMonth()+1)+ '-'+dateTime.getDate()+ ' '+dateTime.getHours()+ ':'+dateTime.getMinutes()+':'+dateTime.getSeconds() comments.unshift(comment) //301永久重定向：浏览器会记住，每次自己就跳转了 //302临时重定向：浏览器不会记住，每次都会向服务器发请求来重定向 res.statusCode = 302 res.setHeader('Location', '/') res.end() } else { fs.readFile('./views/404.html', function(err, data) { if (err) { return res.end('您的页面失联了') } res.end(data) }) } }) //开启服务器监听3000端口 .listen(3000, function () { console.log('running ...') }) 3、把静态资源放到public文件夹中，把写好的页面放到views中index.html 12345678910111213141516171819202122232425262728 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;留言本&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/public/lib/bootstrap/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"header container\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt;Example page header &lt;small&gt;Subtext for header&lt;/small&gt;&lt;/h1&gt; &lt;a class=\"btn btn-success\" href=\"/post\"&gt;发表留言&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"comments container\"&gt; &lt;ul class=\"list-group\"&gt; {{each comments}} &lt;li class=\"list-group-item\"&gt;{{ $value.name }} &lt;b&gt;说：&lt;/b&gt;{{ $value.message }} &lt;span class=\"pull-right\"&gt;{{ $value.dateTime }}&lt;/span&gt;&lt;/li&gt; {{/each}} &lt;/ul&gt; &lt;/div&gt; &lt;!-- &lt;script language=\"JavaScript\"&gt; setTimeout(function(){location.reload()},2000); //指定2秒刷新一次，有明显的刷新过程，看着难受 &lt;/script&gt; --&gt;&lt;/body&gt;&lt;/html&gt; post.html 123456789101112131415161718192021222324252627282930 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/public/lib/bootstrap/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"header container\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt;&lt;a href=\"/\"&gt;首页&lt;/a&gt; &lt;small&gt;发表评论&lt;/small&gt;&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"comments container\"&gt; &lt;form action=\"/pinglun\" method=\"get\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"input_name\"&gt;你的大名&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" required minlength=\"2\" maxlength=\"10\" id=\"input_name\" name=\"name\" placeholder=\"请写入你的姓名（2~10字）\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"textarea_message\"&gt;留言内容&lt;/label&gt; &lt;textarea class=\"form-control\" name=\"message\" id=\"textarea_message\" cols=\"30\" rows=\"10\" required minlength=\"5\" maxlength=\"60\" placeholder=\"请写下您的留言（5~60字）\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;发表&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 404.html 12345678910111213 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;您访问的页面失联了&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 4、开启服务器 然后执行app.js开启一个服务器 在浏览器输入127.0.0.1:3000进行访问 这里有一点要注意：由于使用[]储存留言数据，因此数据没有持久化，每次重启服务，留言就会清空","link":"/2019/08/15/我第二天学nodejs的笔记02/"},{"title":"正则表达式","text":"昨天去多益网络笔试，让再一次我知道了正则表达式有多重要。笔试卷子上考察正则表达式，选择、简答各一道，最后一道编程也考正则。我竟然把test和match是谁的方法都记错了（reg.test(str);str.match(reg)） 一些我的笔记1、声明1let reg = /abc/g i:忽略大小写g:全局匹配m:多行匹配也可以这样声明: 1let reg = new RegExp(\"aBc\",\"i\") 需要注意： 123let reg1 = /abc/glet reg2 = new RegExp(reg1)//这是两个正则表达式 123let reg1 = /abc/glet reg2 =RegExp(reg1)//可以这样用，但这两个变量是同一个正则表达式，两个变量指向同一个地址 2、方法12reg.test(str) //查看str里有没有reg,返回true/falsestr.match(reg) //返回检索内容 3、正则表达式的具体写法1let reg = /[1234567890][1234567890][1234567890]/g 一个[]代表一个字符，里头写取值范围 []里面的写法还是比较随意的,可以用-来指定范围,比如 123let reg = /[0-9A-z][cd][d]/glet reg = /[^a]/g //匹配不是a的字符let reg = /(abc|bcd)/g //匹配一个abc或bcd的子串 []里的细节——元字符. =&gt;[^\\r\\n] 非行结束\\w =&gt;[0-9A-z]\\W =&gt;[^\\w]\\d =&gt;[0-9]\\D =&gt;[^\\d]\\s =&gt;[\\t\\n\\r\\v\\f]\\S =&gt;[^\\s]\\b =&gt;表示匹配单词边界\\B =&gt;非单词边界\\uXXXX =&gt;表示匹配以十六进制编码的Unicode字符一个()代表一个表达式 1234var str=\"aaaa\";var reg =/(\\w)\\1\\1\\1/g;//()表示子表达式；\\1表示引用第一个子表达式var str =\"aabb\";var reg =/(\\w)\\1(\\w)\\2/g; 一些修饰123456* =&gt;匹配1-&gt;∞次+ =&gt;匹配0-&gt;∞次? =&gt;匹配0-&gt;1次{x,y} =&gt;匹配x-&gt;y个^abc =&gt;以abc开头abc$ =&gt;以abc结尾 4、正则表达式里的属性和方法reg.lastIndex //游标reg.exec() //滑动游标 5、案例the-first-name =&gt; theFirstName把the-first-name变成小驼峰式 12345let reg = /-(\\w)/glet str = \"the-first-name\"console.log(str.replace(reg,function($,$1)){ return $1.toUpperCase()})","link":"/2019/08/15/正则表达式有多重要/"},{"title":"创建Stack类的不同方法","text":"读《学习JavaScript数据结构和算法》知识精简本文内容：用JS模拟栈、用栈解决十进制转二进制 创建一个栈需要用一种数据结构来保存数据以及声明栈的一些方法首先，用数组存数据然后，声明如下方法push(elem) :添加元素到栈顶pop() :移除栈顶元素并返回peek() :返回栈顶元素isEmpty() :查看栈是否为空，返回true/falseclear() :移除栈里的所有元素size() :返回栈里的元素个数 声明12345678910111213141516171819202122232425let _items = Symbol()class Stack{ constructor(){ this[_items]=[] } push(elem){ this[_items].push(elem) } pop(){ return this[_items].pop() } peek(){ return this[_items][this[_items].length-1] } isEmpty(){ return this[_items].length==0 } size(){ return this[_items].length } clear(){ this[_items]=[] }} 这样就创建好的一个Stack类，但这里的数组是一个假的私有属性，因为ES6新增的Object.getOwnPropertySymbols方法能够取到类里面声明的所有Symbols属性，很容易被破坏。 用WeakMap实现类1234567891011const items = new WeakMap()class Stack{ constructor(){ items.set(this,[]) } push(elem){ let s = items.get(this) s.push(elem) } //其他方法} 用闭包把Stack类包起来 1234567891011121314let Stack = (fucntion (){ const items = new WeakMap() class Stack{ constructor(){ items.set(this,[]) } push(elem){ let s = items.get(this) s.push(elem) } //其他方法 } return Stack}()) 这样我们终于可以放心的new一个Stack了 用栈解决十进制转换二进制12345678910111213141516function divideBy2(decNumber){ var remStack = new Stack(), rem, binaryString = '' while(decNumber&gt;0){ //只要商大于零就做此循环 rem = Math.floor(decNumber%2) //取余数 remStack.push(rem) decNumber = Math.floor(decNumber/2) //取商 } while(!remStack.isEmpty()){ binaryString += remStack.pop().toString() //出栈 } return binaryString}","link":"/2019/08/15/用JS实现栈/"}],"tags":[{"name":"hello world","slug":"hello-world","link":"/tags/hello-world/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"vuejs","slug":"vuejs","link":"/tags/vuejs/"},{"name":"基础知识","slug":"基础知识","link":"/tags/基础知识/"},{"name":"vuex","slug":"vuex","link":"/tags/vuex/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/正则表达式/"},{"name":"栈","slug":"栈","link":"/tags/栈/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"}],"categories":[{"name":"教学","slug":"教学","link":"/categories/教学/"},{"name":"vuejs","slug":"vuejs","link":"/categories/vuejs/"},{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"nodejs","slug":"nodejs","link":"/categories/nodejs/"},{"name":"正则表达式","slug":"正则表达式","link":"/categories/正则表达式/"},{"name":"数据结构","slug":"数据结构","link":"/categories/数据结构/"}]}